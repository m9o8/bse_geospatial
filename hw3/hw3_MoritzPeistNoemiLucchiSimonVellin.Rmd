---
title: "Geospatial - Assignment 3"
author:
- Moritz Peist
- Noemi Lucchi
- Simon Vellin
output:
  html_document:
    toc: true
    df_print: paged
  pdf_document:
    toc: true
  html_notebook:
    toc: true
---

<hr>

```{css, echo=FALSE}
h1.title {
  text-align: center;
}

h4.author, h4.date {
  text-align: center;
}

.author {
  text-align: center;
}

.date {
  text-align: center;
}
```

```{r setup, include=FALSE}
# Load required package for SVG
library(ragg)

# Disable warning messages and SVG plots
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  # fig.ext = "svg",
  fig.width = 16,
  fig.height = 8,
  fig.retina = 2,
  dpi = 300
  # dev = "svg"
)
```

<div style="text-align: center;">
  <img src="../Barcelona_School_of_Economics_logo.svg" alt="BSE logo">
</div>

<hr>

# Methodology & general code

Throughout this notebook, we will follow the same approach. We begin with Data Loading, where we import and prepare our necessary datasets. We then move to Data Manipulation, where we process and transform our data into the appropriate format for analysis. Finally, in the Visualization section, we create plots to effectively communicate our findings. 

First we load the needed packages:

```{r}
# Package Loading
# Spatial data handling
library(sf) # Simple Features for spatial vector data
library(spData) # Spatial datasets
library(terra) # Raster data handling
library(exactextractr) # Precise spatial averaging
library(gdistance) # Compute minimum distances on raster surfaces

# Additional utilities
library(units) # Unit handling and conversion
library(lwgeom) # Lightweight geometry operations
library(gridExtra) # Arranging multiple plots
library(readxl) # Excel file reading

# Core data manipulation and visualization
library(tidyverse) # Data manipulation and visualization suite
library(ggplot2) # Advanced plotting (included in tidyverse)
```

<hr>

# Exercise 1: Climate change in the USA

## Data Description
The analysis uses two main data sources:

- SPEI (Standardized Precipitation Evapotranspiration Index) data:

  - Source: digital.csic.es
  - Format: NetCDF (.nc) file
  - Resolution: Monthly data
  - Variable: Drought index where negative values indicate dry conditions

- US Geographic Data:

  - Source: spData package
  - Contains: State boundaries and regional classifications
  - Regions: Northeast, Midwest, South, and West

## Data Loading 

To analyze the SPEI (Standardized Precipitation Evapotranspiration Index) trends across US regions over the past 50 years, we need the NetCDF file (.nc) containing SPEI raster data and the US geographic data from spData package.
The .nc file with data about the SPEI index has been downloaded from this [website](https://digital.csic.es/handle/10261/268088).

```{r}
# Import SPEI index
spei_index <- rast("data/ex1/spei01.nc")

# Import US regions
us_states <- spData::us_states
```

## Data Wrangling

We first retrieve all dates from the SPEI index, then select only dates between 1965-2015 (our 50-year analysis period, limited by data availability). 


```{r}
# Get dates from SPEI dataset
dates <- time(spei_index)

# Filter only for years between 1965 and 2015
valid_dates <- which(year(dates) >= 1965 & year(dates) <= 2015)

# Extract the subset of SPEI data for our time period of interest
spei_subset <- spei_index[[valid_dates]]

# Remove from 'dates' the unnecessary dates
dates <- dates[valid_dates]
```

## Methodological Approaches

We implement and compare two methodological approaches. The zonal statistics step computes the average SPEI for each state, creating a wide-format panel where each row is a state and each column represents a specific date (month and year). We then transform this into a long-format panel, adding state and region identifiers along with separated year and month columns. This restructuring enables us to efficiently compute yearly means, first at the state level and then aggregated to the regional level. However, this aggregation creates a `mean-of-means approach`. Below we present a second approach in which we calculate the mean for each region directly without the route via the states. The separation of temporal components (year and month) facilitates these temporal aggregations while maintaining the geographic hierarchy (states nested within regions) for spatial analysis.

### State-to-Region Aggregation (Mean-of-means)

This approach:

- First calculates state-level means from SPEI grid cells
- Then aggregates states to regions
- Potential limitation: Gives equal weight to each state regardless of size


```{r}
# Zonal statistics to compute the mean (each row is a country and each column is a date)
zonal_stats <- exact_extract(
  spei_subset,
  us_states,
  fun = "mean"
)

# Convert the wide format panel to long format panel and add state/region identifiers
# This is necessary to compute the yearly mean per country and then the yearly mean per region
spei_long <- zonal_stats %>%
  as.data.frame() %>%
  # Convert from wide to long format
  pivot_longer(
    cols = everything(),
    names_to = "time_index",
    values_to = "spei"
  ) %>%
  # Add state and region identifiers, plus temporal information
  mutate(
    state = rep(us_states$NAME, each = length(dates)),
    region = rep(us_states$REGION, each = length(dates)),
    date = rep(dates, times = nrow(us_states)),
    year = year(date),
    month = month(date)
  ) %>%
  select(state, region, year, month, spei)

# Compute the yearly mean for each state
spei_state_annual <- spei_long %>%
  group_by(state, region, year) %>%
  summarise(
    mean_spei_state = mean(spei, na.rm = TRUE),
    .groups = "drop"
  )

# Compute the yearly mean for each region
spei_regional <- spei_state_annual %>%
  group_by(region, year) %>%
  summarise(
    mean_spei_region = mean(mean_spei_state, na.rm = TRUE),
    .groups = "drop"
  )
```

### Plotting

After these manipulations, we can create a plot that shows the temporal trends of SPEI index for each region (colored lines) and the overall smoothed trend with confidence interval (blue line).

```{r}
# Plotting
ggplot(spei_regional, aes(x = year, y = mean_spei_region, color = region)) +
  geom_line() +
  geom_smooth(
    data = spei_regional, aes(x = year, y = mean_spei_region),
    method = "loess", color = "blue", se = TRUE
  ) +
  scale_color_manual(values = c("red", "green", "turquoise", "purple")) +
  scale_x_continuous(
    breaks = seq(1970, 2010, by = 10),
    expand = c(0.02, 0.02)
  ) +
  scale_y_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 1)
  ) +
  labs(
    title = "SPEI Index by US Region (1965-2015) - mean-of-means approach",
    x = "Year",
    y = "SPEI Index",
    color = "Region"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
  )
```

### Direct Regional Calculation

Now we will use the direct mean approach by calculating means immediately on the region level across years. Key advantages:

- Directly calculates regional means from SPEI grid cells
- Maintains proper spatial weighting
- More computationally efficient
- Theoretically more sound for spatial averaging

```{r}
# Zonal statistics directly by region (grouping states by region first)
regions_sf <- us_states %>%
  group_by(REGION) %>%
  summarise(geometry = st_union(geometry))

# Calculate SPEI means directly for regions
zonal_stats_regional <- exact_extract(
  spei_subset,
  regions_sf,
  fun = "mean"
)

# Convert to long format with regional identifiers
spei_regional_direct <- zonal_stats_regional %>%
  as.data.frame() %>%
  mutate(region = regions_sf$REGION) %>%
  pivot_longer(
    cols = -region,
    names_to = "time_index",
    values_to = "spei"
  ) %>%
  mutate(
    date = rep(dates, times = nrow(regions_sf)),
    year = year(date)
  ) %>%
  group_by(region, year) %>%
  summarise(
    mean_spei_region = mean(spei, na.rm = TRUE),
    .groups = "drop"
  )
```

### Plotting

Next we plot the results and though the differences to our previous approach are minimal, the direct mean approach is more efficient and should be more what we are looking for:

```{r}
# Plotting
ggplot(spei_regional_direct, aes(x = year, y = mean_spei_region, color = region)) +
  geom_line() +
  geom_smooth(
    data = spei_regional_direct, aes(x = year, y = mean_spei_region),
    method = "loess", color = "blue", se = TRUE
  ) +
  scale_color_manual(values = c("red", "green", "turquoise", "purple")) +
  scale_x_continuous(
    breaks = seq(1970, 2010, by = 10),
    expand = c(0.02, 0.02)
  ) +
  scale_y_continuous(
    limits = c(-1, 1),
    breaks = seq(-1, 1, by = 1)
  ) +
  labs(
    title = "SPEI Index by US Region (1965-2015)",
    x = "Year",
    y = "SPEI Index",
    color = "Region"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5),
  )
```

## Results Interpretation

The plots show:

- SPEI trends for each region (colored lines)
- Overall trend (blue smoothed line with confidence interval)
- Time period: 1965-2015
- Y-axis range: -1 to 1 (drought to wet conditions)

While both approaches yield similar results due to the linear nature of averaging, the direct regional calculation is methodologically preferred for spatial climate data analysis. In comparison the first graph to be replicated looked as follows:

<div style="text-align: center">
  
  ![Figure 1](data/ex1/raster09.png)

</div>

<hr>

# Exercise 2: Transportation Centrality

# Part A

## Data Loading 

To calculate the distances between the 10 top populated cities in Spain, and represent the roads within the continental Spain, we used data from the [Natural Earth website](https://www.naturalearthdata.com/downloads/10m-cultural-vectors/). Precisely, we loaded:
  - ne_10m_populated_places shapefile for the most populated cities 
  - ne_10m_roads for the streets 
  
```{r}
# Load populated cities and roads
places <- st_read("data/ex2/ne_10m_populated_places")
roads <- st_read("data/ex2/ne_10m_roads")
```

## Data Wrangling

From the R package spData, we use the world dataset to extract the geometry of Spain, filtering only for continental Spain. Then, from the dataset containing the most populated cities, we extract only the cities in Spain, sort them in decreasing order of population, and retain only the top 10. Finally, from these top 10 cities, we extract Madrid and Vigo, which will be used in the plot.

```{r}
# Filter for continental Spain only
spain <- world %>%
  filter(name_long == "Spain") %>%
  st_cast("POLYGON") %>%
  slice_max(st_area(.))

# Get top 10 most populated Spanish cities
spain_top_10_cities <- places %>%
  filter(ADM0NAME == "Spain") %>%
  arrange(desc(POP_MAX)) %>%
  slice_head(n = 10)

# Filter Madrid and Vigo for the plot
madrid_vigo <- spain_top_10_cities %>%
  filter(NAME %in% c("Madrid", "Vigo"))
```

## Methodological Approach

First, we transform the CRS from EPSG:4326 to EPSG:3035, as the former uses latitude and longitude, which would lead to incorrect distance calculations in kilometers. Next, we intersect the road network with Spain’s boundaries to restrict the analysis to roads that are actually within Spain. We then create an empty raster over Spain, set a high resolution, and define the CRS as EPSG:3035 for the same reason mentioned earlier. After that, we generate the friction surface by assigning a value of 1 to cells that contain roads and 100 to cells that do not. This ensures that areas without roads have higher friction, influencing the computation of the shortest path between cities. Subsequently, we compute the transition matrix and, finally, calculate and print the distance matrix, which includes all pairwise distances between the top 10 most populated Spanish cities.

```{r}
# Transform to planar EPSG:3035 for better distance calculation in km
spain_planar <- st_transform(spain, 3035)
roads_planar <- st_transform(roads, 3035)
cities_planar <- st_transform(spain_top_10_cities, 3035)

# Intersect roads with Spain's boundaries
spain_roads <- st_intersection(roads_planar, spain_planar)

# Create and prepare a raster on the top of Spain
raster <- rast(ext(spain_planar), resolution = 5000, crs = "EPSG:3035")
roads_vect <- vect(spain_roads)
road_raster <- rasterize(roads_vect, raster, field = 1)

# Create friction surface: we assign 100 to cells without streets and 1 with cells
# with streets. In this way we increase the friction for areas without streets, and so
# streets will be chosen when computing the distances between places.
road_values <- values(road_raster)
road_values[is.na(road_values)] <- 100
road_values[!is.na(road_values)] <- 1
values(road_raster) <- road_values

# Create transition matrix for distance calculation
tr_matrix <- transition(raster(road_raster),
  transitionFunction = mean,
  directions = 8
)

# Calculate distances between all city pairs
n_cities <- nrow(cities_planar)
dist_matrix <- matrix(0, n_cities, n_cities)
rownames(dist_matrix) <- cities_planar$NAME
colnames(dist_matrix) <- cities_planar$NAME

for (i in 1:n_cities) {
  for (j in 1:n_cities) {
    if (i < j) {
      path <- shortestPath(tr_matrix,
        origin = as_Spatial(cities_planar[i, ]),
        goal = as_Spatial(cities_planar[j, ]),
        output = "SpatialLines"
      )
      path_sf <- st_as_sf(path)
      st_crs(path_sf) <- st_crs(cities_planar)
      # Calculate distance in kilometers
      dist <- as.numeric(st_length(path_sf)) / 1000
      dist_matrix[i, j] <- dist
      dist_matrix[j, i] <- dist
    }
  }
}

# Print the distances
print("Distances between cities (km):")
print(round(dist_matrix, 1))
```

## Plotting 

After these manipulations, we can plot continental Spain with its roads, highlighting Madrid and Vigo, as shown in the reference plot.

```{r}
# Plotting
ggplot() +
  geom_sf(data = st_transform(spain, 4326), fill = "lightgray") +
  geom_sf(data = st_transform(spain_roads, 4326), color = "black", size = 0.3) +
  geom_sf(data = st_transform(spain_top_10_cities, 4326), size = 1, color = "black") +
  geom_sf(
    data = st_transform(madrid_vigo %>% filter(NAME == "Madrid"), 4326),
    aes(shape = "Madrid", color = "Madrid"), size = 3
  ) +
  geom_sf(
    data = st_transform(madrid_vigo %>% filter(NAME == "Vigo"), 4326),
    aes(shape = "Vigo", color = "Vigo"), size = 3
  ) +
  scale_color_manual(
    name = "Cities",
    values = c("Madrid" = "red", "Vigo" = "turquoise")
  ) +
  scale_shape_manual(
    name = "Cities",
    values = c("Madrid" = 16, "Vigo" = 17)
  )
```

In comparison the first map looked as follows:

<div style="text-align: center">

  ![Map 1](data/ex2/raster07.png)
</div>

# Part B - Logical Approach

## Data Wrangling

Using the distance matrix calculated in Part A, we now assess the isolation of Madrid and Vigo by analyzing their bilateral distances to the other top 10 most populated cities in Spain. We begin by extracting the distances for Madrid and Vigo.

```{r}
# Extract city names from the top 10 cities (excluding Madrid and Vigo for isolation analysis)
other_cities <- spain_top_10_cities$NAME[!spain_top_10_cities$NAME %in% c("Madrid", "Vigo")]

# Extract distances from Madrid to other cities
madrid_distances <- dist_matrix["Madrid", other_cities]

# Extract distances from Vigo to other cities
vigo_distances <- dist_matrix["Vigo", other_cities]
```

## Analysis

Isolation is determined by comparing the average distances from each city to the others, where a higher average distance indicates greater isolation. We compute summary statistics, and calculate the average distance for each city to make a quantitative comparison.

```{r}
# Calculate summary statistics for isolation
madrid_summary <- summary(madrid_distances)
vigo_summary <- summary(vigo_distances)

# Print summary statistics to compare isolation
cat("\nSummary of distances from Madrid to other top 10 cities (km):\n")
print(round(madrid_summary, 1))
cat("\nSummary of distances from Vigo to other top 10 cities (km):\n")
print(round(vigo_summary, 1))

# Calculate average distances to assess isolation
madrid_avg_distance <- mean(madrid_distances)
vigo_avg_distance <- mean(vigo_distances)

cat("\nAverage distance from Madrid to other cities:", round(madrid_avg_distance, 1), "km\n")
cat("Average distance from Vigo to other cities:", round(vigo_avg_distance, 1), "km\n")

# Determine which city is more isolated (higher average distance indicates more isolation)
if (madrid_avg_distance > vigo_avg_distance) {
  cat("Madrid appears more isolated based on average distance.\n")
} else if (vigo_avg_distance > madrid_avg_distance) {
  cat("Vigo appears more isolated based on average distance.\n")
} else {
  cat("Madrid and Vigo have similar isolation based on average distance.\n")
}
```

## Plotting

To further explore the isolation of Madrid and Vigo, we create smoothed density distributions of their distances to the other top 10 cities. This visualization helps us understand the spread and concentration of distances, where a distribution with a wider spread or higher density at greater distances suggests greater isolation. We use geom_density() to plot the distributions, with Madrid in red and Vigo in turquoise, matching the style of the reference plot.

```{r}
# Create a data frame with distances for plotting
density_data <- data.frame(
  City = c(rep("Madrid", length(madrid_distances)), rep("Vigo", length(vigo_distances))),
  Distance = c(madrid_distances, vigo_distances)
)

# Plot smoothed density distributions using geom_density()
density_plot <- ggplot(density_data, aes(x = Distance, color = City, fill = City)) +
  geom_density(alpha = 0.3) +  # Add transparency for overlap
  scale_color_manual(values = c("Madrid" = "red", "Vigo" = "turquoise")) +
  scale_fill_manual(values = c("Madrid" = "red", "Vigo" = "turquoise")) +
  labs(
    title = "Smoothed Density Distributions of Distances",
    x = "Distance (km)",
    y = "Density",
    color = "City",
    fill = "City"
  ) +
  theme_minimal()

# Display the plot
print(density_plot)
```

In comparison the second graph looked as follows:

<div style="text-align: center">

  ![Map 2](data/ex2/raster08.png)

</div>

# Part B - Alternative Approach

Although we think it seems logical to exclude Madrid and Virgo from the distance calculations, the reference plot seem to include them, as displayed by the noticeable density at x=0 for both cities. In this section, we computed the same plot but with "self-distances" included.

```{r}
# Extract distances for Madrid and Vigo to all cities, including themselves (self-distance = 0)
madrid_distances_all <- dist_matrix["Madrid", ]
vigo_distances_all <- dist_matrix["Vigo", ]

# Create a data frame with distances for plotting, including self-distances
density_data_all <- data.frame(
  City = c(rep("Madrid", length(madrid_distances_all)), rep("Vigo", length(vigo_distances_all))),
  Distance = c(madrid_distances_all, vigo_distances_all)
)

# Plot smoothed density distributions using geom_density(), including self-distances
density_plot_all <- ggplot(density_data_all, aes(x = Distance, color = City, fill = City)) +
  geom_density(alpha = 0.3) +  # Add transparency for overlap
  scale_color_manual(values = c("Madrid" = "red", "Vigo" = "turquoise"), labels = c("Madrid", "Vigo")) +
  scale_fill_manual(values = c("Madrid" = "red", "Vigo" = "turquoise"), labels = c("Madrid", "Vigo")) +
  labs(
    x = "distance",
    y = "density",
    color = "origin",
    fill = "origin"
  ) +
  theme_minimal() +
  theme(
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8)
  )

# Display the plot
print(density_plot_all)
```

</div>