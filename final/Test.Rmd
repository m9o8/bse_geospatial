---
title: "Geospatial Data Science - Final project"
author:
- Moritz Peist
- Noemi Lucchi
- Simon Vellin
subtitle: Analysis of US road accidents and construction sites
output:
  html_document:
    toc: true
    df_print: paged
  html_notebook:
    df_print: paged
    toc: true
---

<hr>

```{css, echo=FALSE}
h1.title {
  text-align: center;
}

h4.author, h4.date {
  text-align: center;
}

.author {
  text-align: center;
}

.date {
  text-align: center;
}

/* Add styling for subtitle */
h3.subtitle {
  text-align: center;
  font-style: italic;
  margin-top: -10px;
  color: #606060;
}
```

<div style="text-align: center;">
  <img src="../Barcelona_School_of_Economics_logo.svg" alt="BSE logo">
</div>

<hr>

Load packages

```{r Packages}
library(data.table)   # For faster data manipulation
library(tidyverse)    # For data manipulation and visualization
library(sf)           # For spatial data handling
library(leaflet)      # For interactive maps
library(leaflet.extras) # For additional leaflet features
library(mapview)      # For easier map visualization
library(tmap)         # For thematic maps
library(tigris)       # For US road networks
library(future)       # For parallel processing
library(future.apply) # For parallel processing with apply functions
library(sf)           # For spatial data handling
# Remove PostgreSQL packages as we're not using them anymore
# library(RPostgres)    # For PostgreSQL connection
# library(DBI)          # For database interface

# Create directories if they don't exist
if (!dir.exists("./data/tigris")) {
  dir.create("./data/tigris", recursive = TRUE)
}

# Set custom cache directory (optional)
options(tigris_cache_dir = "./data/tigris")
# Configure tigris to use caching
options(tigris_use_cache = TRUE)
```


# Set-up convenience functions for parallel processing (as data is quite large)
```{r Parallel Buffering}
# Function to create buffers in batches with proper projection
create_buffers_in_batches <- function(sf_object, buffer_dist, batch_size = 500) {
  # First, reproject to an appropriate projected CRS for the region
  # For California, UTM Zone 10N (EPSG:26910) or 11N (EPSG:26911) works well
  # If we're unsure about your region, a web mercator projection (3857) is a reasonable default
  message("Reprojecting data to a meter-based CRS...")
  sf_object_projected <- st_transform(sf_object, 3310)  # California Albers
  
  n_features <- nrow(sf_object_projected)
  n_batches <- ceiling(n_features / batch_size)
  
  # Create empty list to store results
  buffer_list <- vector("list", n_batches)
  
  # Process in batches
  for (i in 1:n_batches) {
    start_idx <- (i-1) * batch_size + 1
    end_idx <- min(i * batch_size, n_features)
    
    cat(sprintf("Processing batch %d of %d (features %d to %d)\n", 
                i, n_batches, start_idx, end_idx))
    
    # Extract batch
    batch <- sf_object_projected[start_idx:end_idx, ]
    
    # Create buffer (with parallel processing within sf)
    buffer_list[[i]] <- st_buffer(batch, dist = buffer_dist)
  }
  
  # Combine results
  result <- do.call(rbind, buffer_list)
  
  # Reproject back to original CRS if needed
  message("Reprojecting results back to original CRS...")
  st_transform(result, st_crs(sf_object))
}
```



Load data (filter for California for now to limit data set size)

```{r Data Load Accidents}
# Efficient approach
df.acc <- fread("data/us_accidents/US_accidents_March23.csv")[
  # Filter date range of 2021
  lubridate::year(as.Date(Start_Time)) == 2021 & 
  # And California
  State == "CA"
][, `:=`(
  # Add year, quarter, month columns
  year = data.table::year(Start_Time),
  quarter = data.table::quarter(Start_Time),
  month = data.table::month(Start_Time),
  # Calculate duration (assuming End_Time exists in the dataset)
  duration = as.numeric(difftime(End_Time, Start_Time, units = "days"))
)] %>% 
  as_tibble()  # Convert to tibble only at the end for performance
```

```{r Data Load Constructions}
df.const <- fread("data/us_constructions/US_constructions_Dec21.csv")[
  # Filter date range of 2021
  lubridate::year(as.Date(Start_Time)) == 2021 & 
  # And California
  State == "CA"
][, `:=`(
  # Add year, quarter, month columns
  year = year(Start_Time),
  quarter = quarter(Start_Time),
  month = month(Start_Time),
  # Calculate duration (assuming End_Time exists in the dataset)
  duration = as.numeric(difftime(End_Time, Start_Time, units = "days"))
)] %>% 
  as_tibble()  # Convert to tibble only at the end for performance
```

Convert dataframes to sf objects

```{r Geospatial Data}
# Convert accident data to sf object
df.acc.sf <- df.acc %>%
  filter(!is.na(Start_Lat) & !is.na(Start_Lng)) %>%
  st_as_sf(coords = c("Start_Lng", "Start_Lat"), crs = 4326)

# Convert construction data to sf object
df.const.sf <- df.const %>%
  filter(!is.na(Start_Lat) & !is.na(Start_Lng)) %>%
  st_as_sf(coords = c("Start_Lng", "Start_Lat"), crs = 4326)
```


```{r Data Load Roads}
# Get US roads (this can be slow for the entire US, so we might want to limit by state)
# We also only get Primary and Secondary roads as they are the most important (i.e., where most constructions and accidents happen). Otherwise, the dataset would become to large (1.1GB)

ca_roads <- primary_secondary_roads("CA", year = 2021)

# Below code to get ALL roads for California (not recommended due to size)

# First get all counties in California
#ca_counties <- counties("CA", year = 2021)

# Then get roads for each county
#ca_roads_list <- lapply(ca_counties$COUNTYFP, function(county_code) {
#  roads("CA", county = county_code, year = 2021)
#})

# Optionally combine all county road data into one object
#ca_roads <- do.call(rbind, ca_roads_list)
```


```{r Static Maps}
# Static map for Accidents with year coloring
# First, store your plot in a variable
ca_plot <- ggplot() +
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  geom_sf(data = df.acc.sf %>% filter(State == "CA"), 
          aes(color = factor(year)), alpha = 0.7, size = 0.5) +
  scale_color_viridis_d(name = "Year") +  # Use viridis color palette for discrete values
  theme_minimal() +
  labs(title = "US Road Accidents by Year (2016-2021)") +
  theme(legend.position = "bottom")
print(ca_plot)
# Then save it using ggsave
ggsave(filename = "imgs/california_accidents.png", 
       plot = ca_plot,
       width = 10, # width in inches
       height = 8, # height in inches
       dpi = 300)  # resolution

# Construction sites map with year coloring
# First, store our plot in a variable
ca_const_plot <- ggplot() +
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  geom_sf(data = df.const.sf %>% filter(State == "CA"), 
          aes(color = factor(year)), alpha = 0.7, size = 0.5) +
  scale_color_viridis_d(name = "Year") +  # Use viridis color palette for discrete values
  theme_minimal() +
  labs(title = "US Construction Sites by Year (2016-2021)") +
  theme(legend.position = "bottom")
print(ca_const_plot)
# Then save it using ggsave
ggsave(filename = "imgs/california_construction.png", 
       plot = ca_const_plot,
       width = 10, # width in inches
       height = 8, # height in inches
       dpi = 300)  # resolution
```


```{r Heatmap static}
# Create heatmap of accidents using ggplot2
# Modified accident heatmap with transparency for low density areas
accident_heatmap <- ggplot() +
  # Add California roads as base layer
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  # Create density heatmap with transparency threshold
  stat_density_2d(
    data = df.acc %>% filter(!is.na(Start_Lat) & !is.na(Start_Lng)),
    aes(x = Start_Lng, y = Start_Lat, fill = after_stat(density), alpha = after_stat(density)),
    geom = "tile", 
    contour = FALSE,
    h = 0.1,
    n = 200
  ) +
  # Set alpha scaling with a minimum threshold
  scale_alpha_continuous(range = c(0, 0.9), guide = "none") +
  # Use color scheme similar to leaflet's default heatmap
  scale_fill_gradientn(
    colors = c("#0000FF", "#00FFFF", "#00FF00", "#FFFF00", "#FF0000"),
    name = "Accident\nDensity"
  ) +
  coord_sf(
    xlim = c(-124.5, -114.5),
    ylim = c(32.5, 42.5)
  ) +
  theme_minimal() +
  labs(
    title = "Accident Density Heatmap in California (2016-2021)",
    x = NULL,
    y = NULL
  ) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )
# Display the plot
print(accident_heatmap)

ggsave(filename = "imgs/accident_heatmap.png", 
       plot = accident_heatmap,
       width = 10, # width in inches
       height = 8, # height in inches
       dpi = 300)  # resolution

```


```{r Construction Heatmap static}
# Create heatmap of construction sites using ggplot2
construction_heatmap <- ggplot() +
  # Add California roads as base layer
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  # Create density heatmap
  stat_density_2d(
    data = df.const %>% filter(!is.na(Start_Lat) & !is.na(Start_Lng)),
    aes(x = Start_Lng, y = Start_Lat, fill = after_stat(density)),
    geom = "tile", 
    contour = FALSE,
    alpha = 0.7,
    h = 0.1,  # Bandwidth
    n = 200   # Resolution
  ) +
  # Set alpha scaling with a minimum threshold
  scale_alpha_continuous(range = c(0, 0.9), guide = "none") +
  # Use color scheme matching your leaflet construction map
  scale_fill_gradientn(
    colors = c("yellow", "orange", "red"),
    name = "Construction\nDensity"
  ) +
  # Set appropriate boundaries for California
  coord_sf(
    xlim = c(-124.5, -114.5),
    ylim = c(32.5, 42.5)
  ) +
  theme_minimal() +
  labs(
    title = "Construction Density Heatmap in California (2016-2021)",
    x = NULL,
    y = NULL
  ) +
  theme(
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )
# Display the plot
print(construction_heatmap)
```


## Heatmaps - interactive


```{r Interactive Maps I}
# For interactive maps (often better for large datasets)
# Accidents map
accident_map <- leaflet() %>%
  addTiles() %>%
  addHeatmap(data = df.acc.sf, 
             intensity = ~1,
             radius = 8, 
             blur = 10) %>%
  setView(lng = -119.4179, lat = 36.7783, zoom = 6) %>% # Center to CA
  setMaxBounds(lng1 = -124.6, lat1 = 42.0,    # Northwest corner of CA
               lng2 = -114.1, lat2 = 32.5)    # Southeast corner of CA

# Display maps
accident_map
```


```{r Interactive Maps II}
# Construction sites map with California focus and bounds constraints
construction_map <- leaflet() %>%
  addTiles() %>%
  addHeatmap(data = df.const.sf, 
             intensity = ~1,
             radius = 8, 
             blur = 10,
             gradient = c("yellow", "orange", "red")) %>%
  setView(lng = -119.4179, lat = 36.7783, zoom = 6) %>%  # Center on California
  setMaxBounds(lng1 = -124.6, lat1 = 42.0,    # Northwest corner of CA
               lng2 = -114.1, lat2 = 32.5)    # Southeast corner of CA

# Display the map
construction_map
```


We construct construction sites now also as line objects since they have a start and end point

```{r Construction linestrings}
# Convert construction data to linestring sf object
df.const.lines <- df.const %>%
  filter(!is.na(Start_Lat) & !is.na(Start_Lng) & !is.na(End_Lat) & !is.na(End_Lng)) %>%
  mutate(geometry = pmap(list(Start_Lng, Start_Lat, End_Lng, End_Lat), 
                         function(start_lng, start_lat, end_lng, end_lat) {
                           coords <- matrix(c(start_lng, start_lat, 
                                             end_lng, end_lat), 
                                           ncol = 2, byrow = TRUE)
                           st_linestring(coords)
                         })) %>%
  st_sf(crs = 4326)
```


## Spatial operations in R (replacing PostGIS)

```{r R Spatial Operations}
# Set up parallel processing to speed up computations
future::plan(future::multisession, workers = parallel::detectCores() - 1)

cat("Creating construction buffers...\n")

# Step 1A: Create construction point buffers
# Transform to meter-based CRS, buffer, and transform back
construction_buffers <- df.const.sf %>%
  # Add ID as a primary key if it doesn't exist
  mutate(construction_id = if("ID" %in% names(.)) ID else row_number()) %>%
  # Select only needed columns
  select(construction_id, Start_Time, End_Time, geometry) %>%
  # Rename columns to match our schema
  rename(start_time = Start_Time, end_time = End_Time) %>%
  # Create the buffer using our batch function
  create_buffers_in_batches(buffer_dist = 300, batch_size = 500)

cat("Creating construction line buffers...\n")

# Calculate segment length in meters
df.const.lines_with_length <- df.const.lines %>%
  # Transform to meter-based CRS
  st_transform(3310) %>%
  # Calculate length in meters
  mutate(segment_length_m = as.numeric(st_length(geometry))) %>%
  # Transform back to WGS84
  st_transform(4326)

# Step 1A-L: Create construction line buffers
construction_line_buffers <- df.const.lines_with_length %>%
  # Add ID as a primary key if it doesn't exist
  mutate(construction_id = if("ID" %in% names(.)) ID else row_number()) %>%
  # Select only needed columns
  select(construction_id, Start_Time, End_Time, segment_length_m, geometry) %>%
  # Rename columns to match our schema
  rename(start_time = Start_Time, end_time = End_Time) %>%
  # Create the buffer using our batch function
  create_buffers_in_batches(buffer_dist = 300, batch_size = 250)

# Step 1B: Spatial join to find accidents within construction buffers
cat("Finding accidents within construction buffers...\n")
spatial_matches <- df.acc.sf %>%
  # Prepare accident data
  mutate(accident_id = if("ID" %in% names(.)) ID else row_number(),
         accident_severity = if("Severity" %in% names(.)) Severity else NA_integer_,
         accident_time = Start_Time) %>%
  # Select only needed columns
  select(accident_id, accident_severity, accident_time, geometry) %>%
  # Spatial join with construction buffers
  st_join(construction_buffers, join = st_within) %>%
  # Filter for accidents within temporal range of construction
  filter(!is.na(construction_id) & 
         accident_time >= start_time & 
         accident_time <= end_time) %>%
  # Select final columns
  select(accident_id, accident_severity, accident_time, construction_id)

# Step 1B-L: Spatial join to find accidents within construction line buffers
cat("Finding accidents within construction line buffers...\n")
line_spatial_matches <- df.acc.sf %>%
  # Prepare accident data
  mutate(accident_id = if("ID" %in% names(.)) ID else row_number(),
         accident_severity = if("Severity" %in% names(.)) Severity else NA_integer_,
         accident_time = Start_Time) %>%
  # Select only needed columns
  select(accident_id, accident_severity, accident_time, geometry) %>%
  # Spatial join with construction line buffers
  st_join(construction_line_buffers, join = st_within) %>%
  # Filter for accidents within temporal range of construction
  filter(!is.na(construction_id) & 
         accident_time >= start_time & 
         accident_time <= end_time) %>%
  # Select final columns
  select(accident_id, accident_severity, accident_time, construction_id, segment_length_m)

# Step 2: Count construction sites per accident
cat("Counting construction sites per accident...\n")
construction_counts <- spatial_matches %>%
  # Convert to regular dataframe (don't need geometry anymore)
  st_set_geometry(NULL) %>%
  # Group and count
  group_by(accident_id) %>%
  summarize(nearby_construction_count = n())

# Step 2-L: Count construction line sites per accident
cat("Counting construction line sites per accident...\n")
line_construction_counts <- line_spatial_matches %>%
  # Convert to regular dataframe (don't need geometry anymore)
  st_set_geometry(NULL) %>%
  # Group and count
  group_by(accident_id) %>%
  summarize(nearby_line_construction_count = n())

# Step 3: Final analysis table - one construction site per accident
cat("Creating final analysis tables...\n")
# Create a function to randomly select one construction site per accident
select_random_construction <- function(df) {
  df %>%
    group_by(accident_id) %>%
    slice_sample(n = 1) %>%
    ungroup()
}

# Apply for point construction sites
accident_construction_analysis <- spatial_matches %>%
  st_set_geometry(NULL) %>%
  # Join with counts
  left_join(construction_counts, by = "accident_id") %>%
  # Add flags
  mutate(
    construction_type = 'POINT',
    temporal_overlap = 1,
    is_near_active_construction = 1
  ) %>%
  # Select one construction site per accident randomly
  select_random_construction()

# Apply for line construction sites
line_accident_construction_analysis <- line_spatial_matches %>%
  st_set_geometry(NULL) %>%
  # Join with counts
  left_join(line_construction_counts, by = "accident_id") %>%
  # Add flags
  mutate(
    temporal_overlap = 1,
    is_near_active_construction = 1
  ) %>%
  # Select one construction site per accident randomly
  select_random_construction()

# Step 4-L: Calculate accident rates by segment length
cat("Calculating accident rates by segment length...\n")
construction_segment_accident_rates <- df.const.lines_with_length %>%
  # Ensure we have an ID column
  mutate(construction_id = if("ID" %in% names(.)) ID else row_number()) %>%
  # Left join with accident analysis
  left_join(
    line_accident_construction_analysis %>%
      group_by(construction_id) %>%
      summarize(accident_count = n()),
    by = "construction_id"
  ) %>%
  # Replace NA counts with 0
  mutate(accident_count = replace_na(accident_count, 0)) %>%
  # Calculate accidents per km
  mutate(accidents_per_km = accident_count / (segment_length_m / 1000))

# Return to sequential processing
future::plan(future::sequential)

# Total accidents summary - for comparison
total_accidents <- nrow(df.acc.sf)
accidents_near_construction <- nrow(accident_construction_analysis)

cat("Total accidents in dataset:", total_accidents, "\n")
cat("Accidents near active construction:", accidents_near_construction, "\n")
cat("Percentage of accidents near active construction: ", 
    round(accidents_near_construction/total_accidents*100, 2), "%\n")

# Get statistics on construction zones
accidents_per_zone <- construction_segment_accident_rates %>%
  filter(accident_count > 0) %>%
  select(construction_id, accident_count, geometry)

cat("Construction zones with accidents:", nrow(accidents_per_zone), "\n")
cat("Maximum accidents in a single construction zone:", max(accidents_per_zone$accident_count), "\n")
cat("Average accidents per construction zone:", round(mean(accidents_per_zone$accident_count), 2), "\n")

# Join accident data with construction info
accidents_with_construction <- df.acc.sf %>%
  mutate(accident_id = if("ID" %in% names(.)) ID else row_number()) %>%
  left_join(
    accident_construction_analysis %>%
      select(accident_id, construction_id, nearby_construction_count, construction_type),
    by = "accident_id"
  ) %>%
  mutate(near_construction = ifelse(is.na(construction_id), 0, 1))

# Construction density statistics
construction_density_stats <- accident_construction_analysis %>%
  group_by(nearby_construction_count) %>%
  summarize(accident_count = n()) %>%
  arrange(nearby_construction_count)

print(construction_density_stats)

# Severity analysis near line construction
severity_by_construction <- line_accident_construction_analysis %>%
  group_by(accident_severity) %>%
  summarize(count = n()) %>%
  arrange(accident_severity)

# Comparison of accident severity near vs. away from construction
accidents_near <- accidents_with_construction %>%
  filter(near_construction == 1) %>%
  st_set_geometry(NULL) %>%
  mutate(location = "Near construction") %>%
  select(Severity, location)

accidents_away <- accidents_with_construction %>%
  filter(near_construction == 0) %>%
  st_set_geometry(NULL) %>%
  mutate(location = "Away from construction") %>%
  select(Severity, location)

severity_comparison <- bind_rows(accidents_near, accidents_away) %>%
  group_by(Severity, location) %>%
  summarize(count = n(), .groups = "drop") %>%
  arrange(Severity, location)

# Time-based analysis
temporal_analysis <- line_accident_construction_analysis %>%
  mutate(month = floor_date(accident_time, "month")) %>%
  group_by(month) %>%
  summarize(accident_count = n()) %>%
  arrange(month)
```

## Buffer zone analysis

The code below implements the PostGIS functionality directly in R.

```{r Buffer Zone Analysis}
# Visualize construction zones with accident counts
# First, store our plot in a variable
accident_zones_plot <- ggplot() +
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  # Arrange data in descending order so high frequency zones are plotted on top
  geom_sf(data = accidents_per_zone %>% arrange(accident_count), 
          aes(color = accident_count), size = 1.5) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Accident Counts within Construction Zones (2021)")

print(accident_zones_plot)

# Then save it using ggsave
ggsave(filename = "imgs/accident_counts_construction_zones.png", 
       plot = accident_zones_plot,
       width = 10, # width in inches
       height = 8, # height in inches
       dpi = 300)  # resolution
```

## Advanced construction sit analysis (line objects): 

```{r Maps with Construction Lines - static}
# Static map with construction line segments
ggplot() +
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  geom_sf(data = df.const.lines %>% filter(State == "CA"), 
          color = "orange", size = 1) +
  theme_minimal() +
  labs(title = "US Construction Segments (2021)")
```

```{r Maps with Construction Lines - dynamic}
# Interactive map with construction segments focused on California
construction_segment_map <- leaflet() %>%
  addTiles() %>%
  addPolylines(data = df.const.lines, 
               color = "orange",
               weight = 3,
               opacity = 0.7,
               popup = ~paste("ID:", ID, "<br>Duration:", duration)) %>%
  setView(lng = -119.4179, lat = 36.7783, zoom = 6) %>%  # Center on California
  setMaxBounds(lng1 = -124.6, lat1 = 42.0,    # Northwest corner of CA
               lng2 = -114.1, lat2 = 32.5)    # Southeast corner of CA
               
# Display the map
construction_segment_map
```

```{r Construction Impact Analysis with Buffers}
# Visualize segments by accident rate
ggplot() +
  geom_sf(data = ca_roads, color = "gray80", size = 0.1) +
  geom_sf(data = construction_segment_accident_rates, aes(color = accidents_per_km), size = 1.5) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Accident Rate per Construction Segment (2016-2021)",
       color = "Accidents/km")
```


```{r Temporal Analysis and Severity Comparison with Buffers}
# Visualize temporal analysis
ggplot(temporal_analysis, aes(x = month, y = accident_count)) +
  geom_line() +
  geom_point() +
  #scale_x_date(date_labels = "%b %Y", date_breaks = "1 month") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Accidents Near Construction Over Time",
       x = "Month",
       y = "Accident Count")

# Visualize severity comparison
ggplot(severity_comparison, aes(x = Severity, y = count, fill = location)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_brewer(palette = "Set1") +
  theme_minimal() +
  labs(title = "Accident Severity: Near vs. Away from Construction",
       x = "Severity Level",
       y = "Count",
       fill = "Location")
```